#include "precompiled.h"
// Copyright (c) 2005-2009 Jaroslav Gresula
//
// Distributed under the MIT license (See accompanying file
// LICENSE.txt or copy at http://jagpdf.org/LICENSE.txt)
//

// this file was generated by msggen.py

#include <msg_pdflib.h>
#include <boost/format.hpp>

using namespace boost;

namespace jag
{

static
shared_ptr<format> my_fmt( const char* fmtstr )
{
    shared_ptr<format> fmter( new format(fmtstr) );
    fmter->exceptions(io::no_error_bits);
    return fmter;
}


msg_std_sec_handler_rev_perm_clash::msg_std_sec_handler_rev_perm_clash(  )
{
    m_fmt = my_fmt( "The revision of the standard security handler and the permission settings are not compatible." );
    *m_fmt ;
}

msg_std_sec_handler_rev_perm_clash::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_std_sec_handler_rev_perm_clash::msg_id()
{
    return 0x30001;
}



msg_std_sec_handler_rev_key_len_clash::msg_std_sec_handler_rev_key_len_clash(  )
{
    m_fmt = my_fmt( "The revision of the standard security handler and the lenght of the encoding key are not compatible." );
    *m_fmt ;
}

msg_std_sec_handler_rev_key_len_clash::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_std_sec_handler_rev_key_len_clash::msg_id()
{
    return 0x30002;
}



msg_page_already_started::msg_page_already_started(  )
{
    m_fmt = my_fmt( "A page has been already started." );
    *m_fmt ;
}

msg_page_already_started::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_page_already_started::msg_id()
{
    return 0x30005;
}



msg_page_not_started::msg_page_not_started(  )
{
    m_fmt = my_fmt( "No page has been started. Cannot close." );
    *m_fmt ;
}

msg_page_not_started::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_page_not_started::msg_id()
{
    return 0x30006;
}



msg_doc_already_finalized::msg_doc_already_finalized(  )
{
    m_fmt = my_fmt( "The document has been already finalized." );
    *m_fmt ;
}

msg_doc_already_finalized::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_doc_already_finalized::msg_id()
{
    return 0x30007;
}



msg_feature_not_supported::msg_feature_not_supported( char const* p1, int p2, int p3 )
{
    m_fmt = my_fmt( "The feature '%1%' not supported in PDF version 1.%2% (supported from 1.%3%)." );
    *m_fmt  % p1 % p2 % p3;
}

msg_feature_not_supported::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_feature_not_supported::msg_id()
{
    return 0x30008;
}



msg_no_graphics_state_to_pop::msg_no_graphics_state_to_pop(  )
{
    m_fmt = my_fmt( "There is no graphics state to restore." );
    *m_fmt ;
}

msg_no_graphics_state_to_pop::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_no_graphics_state_to_pop::msg_id()
{
    return 0x30009;
}



msg_invalid_paint_cmd::msg_invalid_paint_cmd(  )
{
    m_fmt = my_fmt( "Invalid paint command." );
    *m_fmt ;
}

msg_invalid_paint_cmd::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_invalid_paint_cmd::msg_id()
{
    return 0x3000a;
}



msg_cid_fonts_not_supported::msg_cid_fonts_not_supported(  )
{
    m_fmt = my_fmt( "Composite fonts supported since PDF 1.3." );
    *m_fmt ;
}

msg_cid_fonts_not_supported::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_cid_fonts_not_supported::msg_id()
{
    return 0x3000b;
}



msg_16bits_since_15::msg_16bits_since_15(  )
{
    m_fmt = my_fmt( "16 bits per a color component supported since PDF 1.5." );
    *m_fmt ;
}

msg_16bits_since_15::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_16bits_since_15::msg_id()
{
    return 0x3000d;
}



msg_bookmark_outside_page_def::msg_bookmark_outside_page_def(  )
{
    m_fmt = my_fmt( "Cannot create an outline entry outside a page definition." );
    *m_fmt ;
}

msg_bookmark_outside_page_def::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_bookmark_outside_page_def::msg_id()
{
    return 0x3000e;
}



msg_no_page_for_destination::msg_no_page_for_destination( int p1 )
{
    m_fmt = my_fmt( "The page %1% referenced from a destination does not exist." );
    *m_fmt  % p1;
}

msg_no_page_for_destination::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_no_page_for_destination::msg_id()
{
    return 0x3000f;
}



msg_destination_not_defined::msg_destination_not_defined( int p1 )
{
    m_fmt = my_fmt( "The destination %1% not defined." );
    *m_fmt  % p1;
}

msg_destination_not_defined::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_destination_not_defined::msg_id()
{
    return 0x30010;
}



msg_pattern_no_canvas::msg_pattern_no_canvas(  )
{
    m_fmt = my_fmt( "The pattern canvas is empty." );
    *m_fmt ;
}

msg_pattern_no_canvas::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_pattern_no_canvas::msg_id()
{
    return 0x30012;
}



msg_cannot_output_font::msg_cannot_output_font( char const* p1 )
{
    m_fmt = my_fmt( "Cannot output font %1%." );
    *m_fmt  % p1;
}

msg_cannot_output_font::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_cannot_output_font::msg_id()
{
    return 0x30013;
}



msg_no_chars_used_from_font::msg_no_chars_used_from_font(  )
{
    m_fmt = my_fmt( "Font referenced but no characters were used." );
    *m_fmt ;
}

msg_no_chars_used_from_font::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_no_chars_used_from_font::msg_id()
{
    return 0x30014;
}



msg_invalid_function_spec::msg_invalid_function_spec(  )
{
    m_fmt = my_fmt( "Invalid function specification." );
    *m_fmt ;
}

msg_invalid_function_spec::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_invalid_function_spec::msg_id()
{
    return 0x30015;
}



msg_fn_range_not_set::msg_fn_range_not_set(  )
{
    m_fmt = my_fmt( "Function range not set." );
    *m_fmt ;
}

msg_fn_range_not_set::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_fn_range_not_set::msg_id()
{
    return 0x30017;
}



msg_fn_inconsistent_c0_c1::msg_fn_inconsistent_c0_c1(  )
{
    m_fmt = my_fmt( "Inconsistent values of C0 and C1." );
    *m_fmt ;
}

msg_fn_inconsistent_c0_c1::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_fn_inconsistent_c0_c1::msg_id()
{
    return 0x30018;
}



msg_fn_no_ps_function_specified::msg_fn_no_ps_function_specified(  )
{
    m_fmt = my_fmt( "No PostScript function specified." );
    *m_fmt ;
}

msg_fn_no_ps_function_specified::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_fn_no_ps_function_specified::msg_id()
{
    return 0x30019;
}



msg_invalid_shading_spec::msg_invalid_shading_spec(  )
{
    m_fmt = my_fmt( "Invalid shading pattern specification." );
    *m_fmt ;
}

msg_invalid_shading_spec::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_invalid_shading_spec::msg_id()
{
    return 0x3001a;
}



msg_unknown_shading_type::msg_unknown_shading_type(  )
{
    m_fmt = my_fmt( "Unknown shading pattern type." );
    *m_fmt ;
}

msg_unknown_shading_type::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_unknown_shading_type::msg_id()
{
    return 0x3001b;
}



msg_shading_invalid_space::msg_shading_invalid_space(  )
{
    m_fmt = my_fmt( "Cannot use this color space for the shading pattern." );
    *m_fmt ;
}

msg_shading_invalid_space::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_shading_invalid_space::msg_id()
{
    return 0x3001d;
}



msg_incorrect_matrix::msg_incorrect_matrix(  )
{
    m_fmt = my_fmt( "Matrix requires six values." );
    *m_fmt ;
}

msg_incorrect_matrix::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_incorrect_matrix::msg_id()
{
    return 0x3001e;
}



msg_expected_colored_pattern::msg_expected_colored_pattern(  )
{
    m_fmt = my_fmt( "A shading or colored tiling pattern expected." );
    *m_fmt ;
}

msg_expected_colored_pattern::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_expected_colored_pattern::msg_id()
{
    return 0x3001f;
}



msg_expected_uncolored_pattern::msg_expected_uncolored_pattern(  )
{
    m_fmt = my_fmt( "An uncolored tiling pattern expected." );
    *m_fmt ;
}

msg_expected_uncolored_pattern::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_expected_uncolored_pattern::msg_id()
{
    return 0x30020;
}



msg_invalid_tiling_pattern_spec::msg_invalid_tiling_pattern_spec(  )
{
    m_fmt = my_fmt( "Invalid tiling pattern specification." );
    *m_fmt ;
}

msg_invalid_tiling_pattern_spec::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_invalid_tiling_pattern_spec::msg_id()
{
    return 0x30021;
}




} // namespace jag
/** EOF @file */
