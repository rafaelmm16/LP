#include "precompiled.h"
// Copyright (c) 2005-2009 Jaroslav Gresula
//
// Distributed under the MIT license (See accompanying file
// LICENSE.txt or copy at http://jagpdf.org/LICENSE.txt)
//

// this file was generated by msggen.py

#include <msg_jstd.h>
#include <boost/format.hpp>

using namespace boost;

namespace jag
{

static
shared_ptr<format> my_fmt( const char* fmtstr )
{
    shared_ptr<format> fmter( new format(fmtstr) );
    fmter->exceptions(io::no_error_bits);
    return fmter;
}


msg_icu_failed::msg_icu_failed( int p1, char const* p2 )
{
    m_fmt = my_fmt( "ICU failed with code %1%: %2%." );
    *m_fmt  % p1 % p2;
}

msg_icu_failed::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_icu_failed::msg_id()
{
    return 0x50004;
}



msg_config_integer_value::msg_config_integer_value( char const* p1 )
{
    m_fmt = my_fmt( "Profile option '%1%' requires an integer value." );
    *m_fmt  % p1;
}

msg_config_integer_value::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_config_integer_value::msg_id()
{
    return 0x50005;
}



msg_config_unknown_option::msg_config_unknown_option( char const* p1 )
{
    m_fmt = my_fmt( "Unknown profile option '%1%'." );
    *m_fmt  % p1;
}

msg_config_unknown_option::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_config_unknown_option::msg_id()
{
    return 0x50006;
}



msg_config_parse_error::msg_config_parse_error(  )
{
    m_fmt = my_fmt( "Profile syntax error." );
    *m_fmt ;
}

msg_config_parse_error::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_config_parse_error::msg_id()
{
    return 0x50007;
}



msg_config_unknown_value::msg_config_unknown_value( char const* p1, char const* p2 )
{
    m_fmt = my_fmt( "Unknown value '%2%' for profile option '%1%'." );
    *m_fmt  % p1 % p2;
}

msg_config_unknown_value::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_config_unknown_value::msg_id()
{
    return 0x50008;
}



msg_opt_parser_syntax_err::msg_opt_parser_syntax_err( int p1 )
{
    m_fmt = my_fmt( "Syntax error at offset %1%." );
    *m_fmt  % p1;
}

msg_opt_parser_syntax_err::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_opt_parser_syntax_err::msg_id()
{
    return 0x5000a;
}



msg_opt_parser_value_err::msg_opt_parser_value_err( char const* p1 )
{
    m_fmt = my_fmt( "Unrecognized value '%1%'." );
    *m_fmt  % p1;
}

msg_opt_parser_value_err::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_opt_parser_value_err::msg_id()
{
    return 0x5000b;
}



msg_opt_not_specified::msg_opt_not_specified(  )
{
    m_fmt = my_fmt( "Required option not specified." );
    *m_fmt ;
}

msg_opt_not_specified::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_opt_not_specified::msg_id()
{
    return 0x5000c;
}



msg_opt_length_differs::msg_opt_length_differs(  )
{
    m_fmt = my_fmt( "Incorrect option lenght." );
    *m_fmt ;
}

msg_opt_length_differs::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_opt_length_differs::msg_id()
{
    return 0x5000d;
}



msg_opt_parser_invalid_token::msg_opt_parser_invalid_token( char const* p1 )
{
    m_fmt = my_fmt( "Unrecognized token '%1%'." );
    *m_fmt  % p1;
}

msg_opt_parser_invalid_token::operator msg_info_t() const
{
    return msg_info_t( msg_id(), m_fmt->str() );
}

unsigned msg_opt_parser_invalid_token::msg_id()
{
    return 0x50014;
}




} // namespace jag
/** EOF @file */
